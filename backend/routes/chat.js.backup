const express = require('express');
const { body, validationResult } = require('express-validator');
const { authenticateToken, requireRole, requireOwnership } = require('../middleware/auth');
const { executeQuery, executeTransaction } = require('../config/database');

const router = express.Router();

// Get all chat conversations for a user
router.get('/conversations', authenticateToken, async (req, res) => {
  try {
    const { page = 1, limit = 20 } = req.query;
    const offset = (page - 1) * limit;
    const userId = parseInt(req.user.id);
    const userRole = req.user.user_type;
    
    let whereClause = '';
    let params = [];
    
    if (userRole === 'patient') {
      whereClause = 'WHERE cc.user_id = ?';
      params.push(userId);
    } else if (userRole === 'doctor' || userRole === 'pharmacist') {
      whereClause = 'WHERE cc.facility_id IN (SELECT id FROM healthcare_facilities WHERE user_id = ?)';
      params.push(userId);
    }
    // Admin can see all conversations
    
    const countQuery = `
      SELECT COUNT(*) as total 
      FROM chat_conversations cc
      ${whereClause || 'WHERE 1=1'}
    `;
    
    const conversationsQuery = `
      SELECT 
        cc.*,
        u.first_name, u.last_name, u.email, u.phone,
        hf.name as facility_name, hf.facility_type,
        hp.first_name as professional_first_name, hp.last_name as professional_last_name, hp.specialty, hp.profile_image as professional_profile_image,
        (
          SELECT cm.message 
          FROM chat_messages cm 
          WHERE cm.conversation_id = cc.id 
          ORDER BY cm.created_at DESC 
          LIMIT 1
        ) as last_message,
        (
          SELECT cm.created_at 
          FROM chat_messages cm 
          WHERE cm.conversation_id = cc.id 
          ORDER BY cm.created_at DESC 
          LIMIT 1
        ) as last_message_time,
        (
          SELECT COUNT(*) 
          FROM chat_messages cm 
          WHERE cm.conversation_id = cc.id 
          AND cm.is_read = false 
          AND cm.sender_id != ?
        ) as unread_count
      FROM chat_conversations cc
      JOIN users u ON cc.user_id = u.id
      LEFT JOIN healthcare_facilities hf ON cc.facility_id = hf.id
      LEFT JOIN healthcare_professionals hp ON cc.professional_id = hp.id
      ${whereClause || 'WHERE 1=1'}
      ORDER BY last_message_time DESC, cc.created_at DESC
      LIMIT ? OFFSET ?
    `;
    
    const countResult = await executeQuery(countQuery, params);
    const conversationsResult = await executeQuery(conversationsQuery, [...params, userId, parseInt(limit), offset]);
    
    if (!countResult.success || !conversationsResult.success) {
      return res.status(500).json({ 
        success: false, 
        message: 'Database query failed',
        error: countResult.error || conversationsResult.error
      });
    }
    
    const conversations = conversationsResult.data;
    
    res.json({
      success: true,
      data: {
        conversations,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total: countResult.data[0].total,
          pages: Math.ceil(countResult.data[0].total / limit)
        }
      }
    });
  } catch (error) {
    console.error('Error fetching conversations:', error);
    res.status(500).json({ success: false, message: 'Internal server error' });
  }
});

// Get conversation by ID with messages
router.get('/conversations/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const userId = parseInt(req.user.id);
    const userRole = req.user.user_type;
    
    // Check if conversation exists and user has access
    const conversationResult = await executeQuery(
      `SELECT cc.*, u.first_name, u.last_name, u.email, u.phone,
              hf.name as facility_name, hf.facility_type,
              hp.first_name as professional_first_name, hp.last_name as professional_last_name, hp.specialty, hp.profile_image as professional_profile_image
       FROM chat_conversations cc
       JOIN users u ON cc.user_id = u.id
       LEFT JOIN healthcare_facilities hf ON cc.facility_id = hf.id
       LEFT JOIN healthcare_professionals hp ON cc.professional_id = hp.id
       WHERE cc.id = ?`,
      [id]
    );
    
    if (!conversationResult.success || conversationResult.data.length === 0) {
      return res.status(404).json({ success: false, message: 'Conversation not found' });
    }
    
    const conversation = conversationResult.data[0];
    
    // Check access permissions
    if (userRole === 'patient' && conversation.user_id !== userId) {
      return res.status(403).json({ success: false, message: 'Access denied' });
    }
    
    if ((userRole === 'doctor' || userRole === 'pharmacist') && 
        !await checkFacilityAccess(userId, conversation.facility_id)) {
      return res.status(403).json({ success: false, message: 'Access denied' });
    }
    
    // Get messages for this conversation
    const messagesQuery = `
      SELECT 
        cm.*,
        u.first_name, u.last_name, u.email, u.user_type, u.profile_image as user_profile_image
      FROM chat_messages cm
      JOIN users u ON cm.sender_id = u.id
      WHERE cm.conversation_id = ?
      ORDER BY cm.created_at ASC
    `;
    
    const messagesResult = await executeQuery(messagesQuery, [id]);
    
    if (!messagesResult.success) {
      return res.status(500).json({ 
        success: false, 
        message: 'Failed to fetch messages',
        error: messagesResult.error
      });
    }
    
    const messages = messagesResult.data;
    
    // Mark messages as read for the current user
    if (messages.length > 0) {
      await executeQuery(
        `UPDATE chat_messages 
         SET is_read = true 
         WHERE conversation_id = ? 
         AND sender_id != ? 
         AND is_read = false`,
        [id, userId]
      );
    }
    
    res.json({ 
      success: true, 
      data: { 
        conversation, 
        messages 
      } 
    });
  } catch (error) {
    console.error('Error fetching conversation:', error);
    res.status(500).json({ success: false, message: 'Internal server error' });
  }
});

// Create new conversation
router.post('/conversations', authenticateToken, requireRole(['patient']), [
  body('facility_id').isInt({ min: 1 }),
  body('subject').isLength({ min: 5, max: 100 }).trim(),
  body('initial_message').isLength({ min: 10, max: 500 }).trim(),
  body('message_type').optional().isIn(['general', 'prescription', 'appointment', 'emergency'])
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        success: false, 
        message: 'Validation error', 
        errors: errors.array() 
      });
    }
    
    const conversationData = req.body;
    const userId = parseInt(req.user.id);
    
    // Check if facility exists and is active (or if it's a freelancer)
    console.log('ðŸ” Validating facility_id:', conversationData.facility_id);
    let facility = null;
    
    // First, try to find it as a regular facility
    const facilityResult = await executeQuery(
      'SELECT id, facility_type FROM healthcare_facilities WHERE id = ? AND is_active = true',
      [conversationData.facility_id]
    );
    
    console.log('ðŸ” Facility query result:', facilityResult);
    
    if (facilityResult.success && facilityResult.data && facilityResult.data.length > 0) {
      facility = facilityResult.data[0];
      console.log('âœ… Found regular facility:', facility);
    } else {
      // Check if it's a freelancer (professional ID used as pseudo facility ID)
      console.log('ðŸ” Checking if it\'s a freelancer...');
      const professionalResult = await executeQuery(
        'SELECT id, first_name, last_name, specialty FROM healthcare_professionals WHERE id = ? AND is_verified = true',
        [conversationData.facility_id]
      );
      
      console.log('ðŸ” Professional query result:', professionalResult);
      
      if (professionalResult.success && professionalResult.data && professionalResult.data.length > 0) {
        // It's a freelancer, create a pseudo facility object
        const professional = professionalResult.data[0];
        facility = {
          id: conversationData.facility_id,
          facility_type: 'freelancer',
          name: `${professional.first_name} ${professional.last_name}`,
          specialty: professional.specialty
        };
        console.log('âœ… Found freelancer:', facility);
      }
    }
    
    if (!facility) {
      console.error('âŒ No facility or professional found for ID:', conversationData.facility_id);
      return res.status(404).json({ success: false, message: 'Facility or professional not found' });
    }
    
    // Check if conversation already exists
    const existingResult = await executeQuery(
      'SELECT id FROM chat_conversations WHERE user_id = ? AND facility_id = ? AND status = "active"',
      [userId, conversationData.facility_id]
    );
    
    if (existingResult.success && existingResult.data.length > 0) {
      return res.status(409).json({ 
        success: false, 
        message: 'An active conversation already exists with this facility' 
      });
    }
    
    // Find the professional associated with this facility
    let professionalId = null;
    
    if (facility.facility_type === 'freelancer') {
      // For freelancers, the facility_id is actually the professional_id
      professionalId = conversationData.facility_id;
    } else {
      // For regular facilities, find a professional associated with this facility
      const professionalResult = await executeQuery(
        'SELECT id FROM healthcare_professionals WHERE facility_id = ? AND is_verified = true LIMIT 1',
        [conversationData.facility_id]
      );
      
      if (professionalResult.success && professionalResult.data.length > 0) {
        professionalId = professionalResult.data[0].id;
      } else {
        console.error('âŒ No verified professional found for facility:', conversationData.facility_id);
        return res.status(400).json({ 
          success: false, 
          message: 'No verified professional available at this facility' 
        });
      }
    }
    
    // Create conversation and initial message
    const conversationQuery = `
      INSERT INTO chat_conversations (
        user_id, facility_id, patient_id, professional_id, subject, conversation_type, status, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, 'active', NOW())
    `;
    
    const conversationResult = await executeQuery(conversationQuery, [
      userId,
      conversationData.facility_id,
      userId, // patient_id is the same as user_id for patients
      professionalId,
      conversationData.subject,
      conversationData.message_type || 'general'
    ]);
    
    if (!conversationResult.success) {
      console.error('âŒ Failed to create conversation:', conversationResult.error);
      return res.status(500).json({ 
        success: false, 
        message: 'Failed to create conversation',
        error: conversationResult.error
      });
    }
    
    const conversationId = conversationResult.data.insertId;
    console.log('âœ… Conversation created with ID:', conversationId);
    
    // Create initial message
    const messageQuery = `
      INSERT INTO chat_messages (
        conversation_id, sender_id, message, message_type, created_at
      ) VALUES (?, ?, ?, ?, NOW())
    `;
    
    const messageResult = await executeQuery(messageQuery, [
      conversationId,
      userId,
      conversationData.initial_message,
      conversationData.message_type || 'general'
    ]);
    
    if (!messageResult.success) {
      console.error('âŒ Failed to create initial message:', messageResult.error);
      return res.status(500).json({ 
        success: false, 
        message: 'Failed to create initial message',
        error: messageResult.error
      });
    }
    
    console.log('âœ… Initial message created');
    
    // Get the created conversation with proper facility information
    console.log('ðŸ” Fetching created conversation with ID:', conversationId);
    const newConversationResult = await executeQuery(`
      SELECT 
        cc.*,
        u.first_name, u.last_name, u.email, u.phone,
        hf.name as facility_name, hf.facility_type,
        hp.first_name as professional_first_name, hp.last_name as professional_last_name, hp.specialty
      FROM chat_conversations cc
      JOIN users u ON cc.user_id = u.id
      LEFT JOIN healthcare_facilities hf ON cc.facility_id = hf.id
      LEFT JOIN healthcare_professionals hp ON cc.professional_id = hp.id
      WHERE cc.id = ?
    `, [conversationId]);
    
    console.log('ðŸ” Conversation query result:', newConversationResult);
    
    if (!newConversationResult.success || !newConversationResult.data || newConversationResult.data.length === 0) {
      console.error('âŒ Failed to fetch created conversation:', newConversationResult);
      return res.status(500).json({ 
        success: false, 
        message: 'Failed to fetch created conversation',
        error: newConversationResult.error || 'Unknown error'
      });
    }
    
    const conversation = newConversationResult.data[0];
    
    // Format the conversation response
    const conversationResponse = {
      id: conversation.id,
      user_id: conversation.user_id,
      facility_id: conversation.facility_id,
      subject: conversation.subject,
      conversation_type: conversation.conversation_type,
      status: conversation.status,
      created_at: conversation.created_at,
      facility_name: conversation.facility_name || `${conversation.professional_first_name} ${conversation.professional_last_name}`,
      facility_type: conversation.facility_type || 'freelancer',
      professional_first_name: conversation.professional_first_name,
      professional_last_name: conversation.professional_last_name,
      user: {
        first_name: conversation.first_name,
        last_name: conversation.last_name,
        email: conversation.email,
        phone: conversation.phone
      },
      facility: {
        id: conversation.facility_id,
        name: conversation.facility_name || `${conversation.professional_first_name} ${conversation.professional_last_name}`,
        facility_type: conversation.facility_type || 'freelancer',
        specialty: conversation.specialty
      }
    };
    
    res.status(201).json({ 
      success: true, 
      message: 'Conversation created successfully',
      data: { 
        conversation: conversationResponse,
        message: {
          id: conversationId, // This would be the message ID, but we're using conversation ID for simplicity
          conversation_id: conversationId,
          sender_id: userId,
          message: conversationData.initial_message,
          message_type: conversationData.message_type || 'general',
          created_at: new Date().toISOString()
        }
      }
    });
  } catch (error) {
    console.error('Error creating conversation:', error);
    res.status(500).json({ success: false, message: 'Internal server error' });
  }
});

// Send message in conversation
router.post('/conversations/:id/messages', authenticateToken, [
  body('message').isLength({ min: 1, max: 500 }).trim(),
  body('message_type').optional().isIn(['text', 'image', 'file', 'prescription']),
  body('attachment_url').optional().isURL()
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        success: false, 
        message: 'Validation error', 
        errors: errors.array() 
      });
    }
    
    const { id } = req.params;
    const { message, message_type = 'text', attachment_url } = req.body;
    const userId = parseInt(req.user.id);
    const userRole = req.user.user_type;
    
    // Check if conversation exists and user has access
    const conversationResult = await executeQuery(
      'SELECT * FROM chat_conversations WHERE id = ?',
      [id]
    );
    
    if (!conversationResult.success || conversationResult.data.length === 0) {
      return res.status(404).json({ success: false, message: 'Conversation not found' });
    }
    
    const conversation = conversationResult.data[0];
    
    if (conversation.status !== 'active') {
      return res.status(400).json({ success: false, message: 'Conversation is not active' });
    }
    
    // Check access permissions
    if (userRole === 'patient' && conversation.user_id !== userId) {
      return res.status(403).json({ success: false, message: 'Access denied' });
    }
    
    if ((userRole === 'doctor' || userRole === 'pharmacist') && 
        !await checkFacilityAccess(userId, conversation.facility_id)) {
      return res.status(403).json({ success: false, message: 'Access denied' });
    }
    
    // Create message
    const messageQuery = `
      INSERT INTO chat_messages (
        conversation_id, sender_id, message, message_type, attachment_url, created_at
      ) VALUES (?, ?, ?, ?, ?, NOW())
    `;
    
    const result = await executeQuery(messageQuery, [
      id,
      userId,
      message,
      message_type,
      attachment_url || null
    ]);
    
    if (!result.success) {
      return res.status(500).json({ 
        success: false, 
        message: 'Failed to send message',
        error: result.error
      });
    }
    
    // Update conversation last_activity
    await executeQuery(
      'UPDATE chat_conversations SET last_activity = NOW() WHERE id = ?',
      [id]
    );
    
    res.status(201).json({ 
      success: true, 
      message: 'Message sent successfully',
      data: { id: result.data.insertId }
    });
  } catch (error) {
    console.error('Error sending message:', error);
    res.status(500).json({ success: false, message: 'Internal server error' });
  }
});

// Update conversation status
router.patch('/conversations/:id/status', authenticateToken, [
  body('status').isIn(['active', 'resolved', 'closed']),
  body('resolution_notes').optional().isLength({ max: 200 }).trim()
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        success: false, 
        message: 'Validation error', 
        errors: errors.array() 
      });
    }
    
    const { id } = req.params;
    const { status, resolution_notes } = req.body;
    const userId = parseInt(req.user.id);
    const userRole = req.user.user_type;
    
    // Check if conversation exists and user has access
    const conversationResult = await executeQuery(
      'SELECT * FROM chat_conversations WHERE id = ?',
      [id]
    );
    
    if (!conversationResult.success || conversationResult.data.length === 0) {
      return res.status(404).json({ success: false, message: 'Conversation not found' });
    }
    
    const conversation = conversationResult.data[0];
    
    // Check access permissions
    if (userRole === 'patient' && conversation.user_id !== userId) {
      return res.status(403).json({ success: false, message: 'Access denied' });
    }
    
    if ((userRole === 'doctor' || userRole === 'pharmacist') && 
        !await checkFacilityAccess(userId, conversation.facility_id)) {
      return res.status(403).json({ success: false, message: 'Access denied' });
    }
    
    // Update conversation status
    const updateQuery = `
      UPDATE chat_conversations 
      SET status = ?, resolution_notes = ?, updated_at = NOW()
      WHERE id = ?
    `;
    
    await executeQuery(updateQuery, [status, resolution_notes || null, id]);
    
    res.json({ success: true, message: 'Conversation status updated successfully' });
  } catch (error) {
    console.error('Error updating conversation status:', error);
    res.status(500).json({ success: false, message: 'Internal server error' });
  }
});

// Mark messages as read
router.patch('/conversations/:id/read', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const userId = parseInt(req.user.id);
    
    // Check if conversation exists and user has access
    const conversationResult = await executeQuery(
      'SELECT * FROM chat_conversations WHERE id = ?',
      [id]
    );
    
    if (!conversationResult.success || conversationResult.data.length === 0) {
      return res.status(404).json({ success: false, message: 'Conversation not found' });
    }
    
    const conversation = conversationResult.data[0];
    
    // Check access permissions
    if (conversation.user_id !== userId && 
        !await checkFacilityAccess(userId, conversation.facility_id)) {
      return res.status(403).json({ success: false, message: 'Access denied' });
    }
    
    // Mark all unread messages as read
    await executeQuery(
      `UPDATE chat_messages 
       SET is_read = true 
       WHERE conversation_id = ? 
       AND sender_id != ? 
       AND is_read = false`,
      [id, userId]
    );
    
    res.json({ success: true, message: 'Messages marked as read' });
  } catch (error) {
    console.error('Error marking messages as read:', error);
    res.status(500).json({ success: false, message: 'Internal server error' });
  }
});

// Get unread message count for user
router.get('/unread-count', authenticateToken, async (req, res) => {
  try {
    const userId = parseInt(req.user.id);
    const userRole = req.user.user_type;
    
    let whereClause = '';
    let params = [];
    
    if (userRole === 'patient') {
      whereClause = 'WHERE cc.user_id = ?';
      params.push(userId);
    } else if (userRole === 'doctor' || userRole === 'pharmacist') {
      whereClause = 'WHERE cc.facility_id IN (SELECT id FROM healthcare_facilities WHERE user_id = ?)';
      params.push(userId);
    }
    
    // Add the additional conditions
    const additionalConditions = 'cm.sender_id != ? AND cm.is_read = false';
    const finalWhereClause = whereClause ? 
      `${whereClause} AND ${additionalConditions}` : 
      `WHERE ${additionalConditions}`;
    
    const query = `
      SELECT 
        COUNT(*) as total_unread,
        COUNT(DISTINCT cc.id) as conversations_with_unread
      FROM chat_messages cm
      JOIN chat_conversations cc ON cm.conversation_id = cc.id
      ${finalWhereClause}
    `;
    
    const result = await executeQuery(query, [...params, userId]);
    
    if (!result.success) {
      return res.status(500).json({ 
        success: false, 
        message: 'Failed to get unread count',
        error: result.error
      });
    }
    
    res.json({ 
      success: true, 
      data: result.data[0] || { total_unread: 0, conversations_with_unread: 0 }
    });
  } catch (error) {
    console.error('Error fetching unread count:', error);
    res.status(500).json({ success: false, message: 'Internal server error' });
  }
});

// Helper function to check facility access
async function checkFacilityAccess(userId, facilityId) {
  const facilityResult = await executeQuery(
    'SELECT id FROM healthcare_facilities WHERE id = ? AND user_id = ?',
    [facilityId, userId]
  );
  return facilityResult.success && facilityResult.data.length > 0;
}

module.exports = router; 